package v1

import (
	"context"
	"database/sql"
	"encoding/json"
	"net/http"
	"strconv"

	"github.com/gorilla/mux"
	"github.com/saime-0/http-cute-chat/internal/api/responder"
	"github.com/saime-0/http-cute-chat/internal/api/rules"
	"github.com/saime-0/http-cute-chat/internal/models"
)

type pipeline struct {
	Ctx    context.Context
	w      http.ResponseWriter
	r      *http.Request
	h      *Handler
	cancel bool
}

func initPipeline(w http.ResponseWriter, r *http.Request, h *Handler) *pipeline {
	return &pipeline{
		Ctx:    r.Context(),
		w:      w,
		r:      r,
		h:      h,
		cancel: false,
	}
}

func (p *pipeline) set(key, val interface{}) {
	p.Ctx = context.WithValue(p.Ctx, key, val)
}

func (p *pipeline) get(key interface{}) (val interface{}) {
	return p.Ctx.Value(key)
}

func finalInspectionDatabase(w http.ResponseWriter, err error) {
	switch {
	case err == sql.ErrNoRows:
		responder.Error(w, http.StatusInternalServerError, rules.ErrDataRetrieved)
		panic(err)

	case err != nil:
		responder.Error(w, http.StatusInternalServerError, rules.ErrAccessingDatabase)
		panic(err)
	}
}

// todo передавать строки в параметры
func (p *pipeline) parseUserDomainFromRequest() {
	if p.cancel {
		return
	}
	user_domain := mux.Vars(p.r)["user-domain"]
	if !validateDomain(user_domain) {
		responder.Error(p.w, http.StatusBadRequest, rules.ErrInvalidValue)
		p.cancel = true
		return
	}
	p.set(rules.PipeLineUserDomain, user_domain)
}

func (p *pipeline) parseUserIDFromRequest() {
	if p.cancel {
		return
	}
	user_id, err := strconv.Atoi(mux.Vars(p.r)["user-id"])
	if err != nil {
		responder.Error(p.w, http.StatusBadRequest, rules.ErrInvalidValue)
		p.cancel = true
		return
	}
	p.set(rules.PipeLineUserID, user_id)
}

func (p *pipeline) inspectUserExistsByDomain() {
	if p.cancel {
		return
	}
	user_domain := p.get(rules.PipeLineUserDomain).(string)
	if !p.h.Services.Repos.Users.UserExistsByDomain(user_domain) {
		responder.Error(p.w, http.StatusBadRequest, rules.ErrUserNotFound)
		p.cancel = true
		return
	}
}

func (p *pipeline) inspectUserExistsByID() {
	if p.cancel {
		return
	}
	user_id := p.get(rules.PipeLineUserID).(int)
	if !p.h.Services.Repos.Users.UserExistsByID(user_id) {
		responder.Error(p.w, http.StatusBadRequest, rules.ErrUserNotFound)
		p.cancel = true
		return
	}
}

func (p *pipeline) parseUserNameFromQuery() {
	if p.cancel {
		return
	}
	name_fragment := p.r.URL.Query().Get("name")
	if len(name_fragment) > rules.NameMaxLength || len(name_fragment) == 0 {
		responder.Error(p.w, http.StatusBadRequest, rules.ErrInvalidValue)
		p.cancel = true
		return
	}
	p.set(rules.PipeLineFragmentName, name_fragment)
}

func (p *pipeline) parseOffsetFromQuery() {
	if p.cancel {
		return
	}
	offset, err := strconv.Atoi(p.r.URL.Query().Get("offset"))
	if err != nil && p.r.URL.Query().Get("offset") != "" {
		responder.Error(p.w, http.StatusBadRequest, rules.ErrInvalidValue)
		p.cancel = true
		return
	}

	if offset < 0 {
		responder.Error(p.w, http.StatusBadRequest, rules.ErrOutOfRange)
		p.cancel = true
		return
	}
	p.set(rules.PipeLineOffset, offset)
}

func (p *pipeline) parseUserUpdateDataModel() {
	if p.cancel {
		return
	}
	user_data := &models.UpdateUserData{}
	err := json.NewDecoder(p.r.Body).Decode(&user_data)
	if err != nil {
		responder.Error(p.w, http.StatusBadRequest, rules.ErrBadRequestBody)
		p.cancel = true
		return
	}

	if (!validateName(user_data.Name) && len(user_data.Name) == 0) && (!validateName(user_data.Domain) && len(user_data.Domain) == 0) {
		responder.Error(p.w, http.StatusBadRequest, rules.ErrInvalidValue)
		p.cancel = true
		return
	}
	p.set(rules.PipeLineUserUpdateDataModel, user_data)
}

func (p *pipeline) parseUserUpdateSettingsModel() {
	if p.cancel {
		return
	}
	user_settings := &models.UpdateUserSettings{}
	err := json.NewDecoder(p.r.Body).Decode(&user_settings)
	if err != nil {
		responder.Error(p.w, http.StatusBadRequest, rules.ErrBadRequestBody)
		p.cancel = true
		return
	}

	if !validateAppSettings(user_settings.AppSettings) {
		responder.Error(p.w, http.StatusBadRequest, rules.ErrInvalidValue)
		p.cancel = true
		return
	}
	p.set(rules.PipeLineUserUpdateSettingsModel, user_settings)
}

func (p *pipeline) parseChatDomainFromRequest() {
	if p.cancel {
		return
	}
	chat_domain := mux.Vars(p.r)["chat-domain"]
	if !validateDomain(chat_domain) {
		responder.Error(p.w, http.StatusBadRequest, rules.ErrInvalidValue)
		p.cancel = true
		return
	}
	p.set(rules.PipeLineChatDomain, chat_domain)
}

func (p *pipeline) parseChatIDFromRequest() {
	if p.cancel {
		return
	}
	chat_id, err := strconv.Atoi(mux.Vars(p.r)["chat-id"])
	if err != nil {
		responder.Error(p.w, http.StatusBadRequest, rules.ErrInvalidValue)
		p.cancel = true
		return
	}
	p.set(rules.PipeLineChatID, chat_id)
}

func (p *pipeline) inspectChatExistsByDomain() {
	if p.cancel {
		return
	}
	chat_domain := p.get(rules.PipeLineChatDomain).(string)
	if !p.h.Services.Repos.Chats.ChatExistsByDomain(chat_domain) {
		responder.Error(p.w, http.StatusBadRequest, rules.ErrChatNotFound)
		p.cancel = true
		return
	}
}

func (p *pipeline) inspectChatExistsByID() {
	if p.cancel {
		return
	}
	chat_id := p.get(rules.PipeLineChatID).(int)
	if !p.h.Services.Repos.Chats.ChatExistsByID(chat_id) {
		responder.Error(p.w, http.StatusBadRequest, rules.ErrChatNotFound)
		p.cancel = true
		return
	}
}

func (p *pipeline) parseCreateChatModel() {
	if p.cancel {
		return
	}
	chat := &models.CreateChat{}
	err := json.NewDecoder(p.r.Body).Decode(&chat)
	if err != nil {
		responder.Error(p.w, http.StatusBadRequest, rules.ErrBadRequestBody)
		p.cancel = true
		return
	}

	user_id := p.r.Context().Value(rules.UserIDFromToken).(int)
	count_chats, err := p.h.Services.Repos.Users.GetCountUserOwnedChats(user_id)
	if err != nil {
		responder.Error(p.w, http.StatusInternalServerError, rules.ErrAccessingDatabase)
		p.cancel = true
		return
	}

	if count_chats >= rules.MaxCountOwnedChats {
		responder.Error(p.w, http.StatusBadRequest, rules.ErrLimitHasBeenReached)
		p.cancel = true
		return
	}
}
